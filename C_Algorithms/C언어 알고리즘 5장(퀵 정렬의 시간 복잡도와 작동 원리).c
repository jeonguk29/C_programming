#include <stdio.h>

int number = 10;
int data[] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};

void quickSort(int* data, int start, int end) { // 사실상 스타트가 키값임 엔드가 그 범위에 마지막이고  
   if (start >= end) { // 원소가 1개인 경우 그대로 두기 스타트는 정렬을 수행하는 그 부분 집합의 첫번째 엔드는 마지막  
      return;
   }
   
   int key = start; // 키는 첫 번째 원소
   int i = start + 1, j = end, temp;  // i = 큰값 j 는 작은 값  
   
   while(i <= j) { // 엇갈리기 전까지 까지 반복
      while(data[i] <= data[key] && i <= end ) { // 키 값보다 큰 값을 만날 때까지 
         i++;
      }
      while(data[j] >= data[key] && j > start ) { // 키 값보다 작은 값을 만날 때까지 
         j--;
      }
      if(i > j) { // 현재 엇갈린 상태면 키 값과 교체 
         temp = data[j];
         data[j] = data[key];
         data[key] = temp;
      } else { // 엇갈리지 않았다면 i와 j를 교체 
         temp = data[i];
         data[i] = data[j];
         data[j] = temp;
      }
   } 
   
   quickSort(data, start, j - 1); //결과 적으로 데이터가 엇갈려서 밖으로 빠져 나왔다면 그 키값을 기준으로 왼쪽과 오른쪽에서  각각 다시 퀵정렬을 수행 해주는 것임 
   quickSort(data, j + 1, end); // 1 2 (3) 8 5 9 6 10 7 4 이거랑 같은 상황  
   
    /*
   1 2 3 7 5 4 6 (8) 10 9  이 특정한 숫자를 기준으로 왼쪽과 오른쪽이 각각 정렬이 이루어 
   지는데요 8보다 작은건   1 2 3 7 5 4 6 큰건  10 9 이쪽에 있음 이제 이상태에서 각각 왼쪽과 오른쪽에서 또 정렬을 수행해 준다고 했음  

   quickSort(data, start, j - 1);  이건 1 2 
   quickSort(data, j + 1, end);  이건 8 5 9 6 10 7 4 여기를 수행 해줌 
   이제 이렇게 똑같은 함수안에 똑같은 함수가 들어가는 재귀적 함수를 이용하는 방식으로 퀵 정렬을 구현 할수가 있는 것임   
   이걸 단순하게 실행만 해주면 안정적으로 정렬이 된다고 할수 있음  
   */
}

int main(void) {
   quickSort(data, 0, number - 1);
   int i;
   for(i = 0; i < number; i++) {
      printf("%d ", data[i]);
   }
   return 0;
}





/*
#include <stdio.h>

int number = 10; //데이터의 개수는 총 10개  
int data[] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9}; // 열개의 데이터가 들어 간걸 확인 할 수 있음  

void quickSort(int* data, int start, int end) { // 퀵정렬을 수행하는 함수 start : 정렬을 수행하는 그 부분 집합의 첫 번째 end : 마지막  
   if (start >= end) { // 스타트가 앤드랑 같거나 크다는 소리는 기본적으로 원소가 1개인 경우 그대로 두기 
      return; // 바로 리턴  
   }
   
   int key = start; // 흔히 피벗값을 키값 이라고 부름 키는 첫 번째 원소 
   // 즉 맨처음에 피벗 값을 첫번째 값으로 선택을 하는데  바로 그 뜻임  {1, 10, 5, 8, 7, 6, 4, 3, 2, 9} 특정한 부분 집합에서 첫번째 값을 키값으로 삼는다 
   int i = start + 1; // i 같은 경우는 왼쪽 부터 하나씩 10, 5, 8, 7, 6, 4, 3, 2, 9 큰값을 찿을 때 그 인덱스를 의미함 기본 적으로 키값의 바로 오른쪽 부터 
   // 시작을 해서 오른쪽으로 한칸씩 이동하며 키값 보다 큰것을 찾아야되기 때문에 +1을 해준 것임   
   int j = end; // j는 마지막 값임 10, 5, 8, 7, 6, 4, 3, 2, 9  왼쪽으로 작은 값을 찾기위해 이동을 하는데 그것 을 위해 j를 만든것임 
   // 즉 i는 왼쪽 출발지점 j는 오른쪽 출발지점 이라고 할수 있음  
   int temp;// 두가지 값의 위치를 바꿀수 있도록 임시 변수를 만든 것임  
   
   while(i <= j) 
   { // 엇갈릴 때까지 반복  흔히 엇갈리는 경우 더 왼쪽에 있는 값과  피벗 값을 바꿔 준다고 했는데 그렇기 때문에 언제 엇갈리는지 확인을 하는것임 
   // i가 j보다 작거나 같을때 까지 반복을 함  즉 다시 말해 왼쪽부터 출발한게 오른쪽 부터 출발한것 보다 더 작을 때 까지만 즉 엇갈리지 않았을때까지만 반복을 하기 때문에
   // 엇갈리면 탈출을 함    
      while(i <= end && data[i] <= data[key])// 키 값보다 큰 값을 만날 때까지  
	   { // 즉 i가 키 값보다 작다면 i를 한칸씩 오른쪽으로 이동 시켜주는 것임 키 값보다 큰 값을 만날 때까지  
         i++;
      }
      while(j > start && data[j] >= data[key]) // 키 값보다 작은 값을 만날 때까지 
	  { // 즉 j가 키값보다 크거나 같다면 j를 1씩 빼주면서 왼쪽으로 이동시켜 주는 것임 키 값보다 작은 값을 만날 때까지 반복  
	    // j > start 이걸 꼭 설정 해주어야함 j가 스타드보다 크다는 것을 그이유는 만약 1보다 작은 값을 고른다고 했을 때 9부터 출발을 하는데 1보다 작은 값이 없음 
		// 더 넘어 가면 안되기 때문에 최대한 커 봤자 스타트 까지만 가게 해주는 것임 즉 범위를 넘어가지 안토록 걸어주는 것임 
		// 하지만  data[i] <= data[key] 위에는 안해주는 이유가 엇갈렸을 때 교체를 해주니까 교체를 할때 왼쪽에 있는 값과 키값을 교체 해주기 때문에 왼쪽으로만 넘어가지 않도록
		// 해주면 문제가 없는 것임 그래서 오른쪽은 굳이 설정해줄 필요가 없음   
         j--;
      }
      if(i > j) { // 현재 엇갈린 상태면 키 값과 교체 
         temp = data[j];
         data[j] = data[key]; // 이전 시간 과 마찬가지로 데이터가 엇갈렸을때 왼쪽에 있는 값과 키값을 바꿔 주는 것이고  
         data[key] = temp;
      } else { // 엇갈리지 않았다면 i와 j를 교체 
         temp = data[i];
         data[i] = data[j]; // 엇갈리지 않았다면 큰 값과 작은 값을 서로 바꿔줌  
         data[j] = temp;
      }
   } 
   
   quickSort(data, start, j - 1); // 결과 적으로 데이터가 엇갈려서 밖으로 빠져 나왔다면  
   quickSort(data, j + 1, end);  // 그 키값을 기준으로 왼쪽과 오른쪽에서  각각 다시 퀵정렬을 수행 해주는 것임 
   // 지난시간에 했던 것과 마찮가지로 한번 정렬이 끝나게 되면  1 2 3 7 5 4 6 (8) 10 9  이 특정한 숫자를 기준으로 왼쪽과 오른쪽이 각각 정렬이 이루어 
   // 지는데요 8보다 작은건   1 2 3 7 5 4 6 큰건  10 9 이쪽에 있음 이제 이상태에서 각각 왼쪽과 오른쪽에서 또 정렬을 수행해 준다고 했음  
   /*
   quickSort(data, start, j - 1);  즉 7 5 4 6 여기를 수행 해주고  
   quickSort(data, j + 1, end);  이건 10 9 여기를 수행 해줌 
   이제 이렇게 똑같은 함수안에 똑같은 함수가 들어가는 재귀적 함수를 이용하는 방식으로 퀵 정렬을 구현 할수가 있는 것임   
   이걸 단순하게 실행만 해주면 안정적으로 정렬이 된다고 할수 있음  
   
}

int main(void) {
   // 배열을 맨처음 선언 을 해주엇기 때문에 바로 한번 함수를 이용해서 실행을 해보겠음 	
   quickSort(data, 0, number - 1); // 즉 인덱스 0 부터 인덱스 9 까지 정렬을 수행 하는 것이고 
   int i; 
   for(i = 0; i < number; i++) { // 정렬된 데이터를 출력 하도록 하는 것  
    printf("%d ", data[i]);
   }
   
   // 이런 식으로 퀵정렬은 자기보다 큰 값과 작은 값을 엇갈릴때 까지 반복해서 교체하는 식으로 작동을 함  => 다시 노트장으로 넘어가기  
   return 0;
}

*/
