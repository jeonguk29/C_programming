#include <stdio.h>
int number = 8; // 기본적으로 정렬하 데이터의 개수가 8개  

int size;
int sorted[8]; // 정렬된 결과 배열을 담을수 있는 공간 *정렬 배열은 반드시 전역 변수로 선언*
// 정렬을  수행할때 기존의 배열 뿐만 아니라 추가적인 배열이 필요하다는 특징을 가지고 있음
// 4개의 데이터를 정렬하기 위해서는 4개만큼의 추가적인 배열이 필요한것임 
// 이제 메인 함수 안에 필요할때마다 배열을 생성 한다고 하면 굉장히 비효율 적으로 작동할 가능 성이 큼 
// 반면에 이렇게 전역 변수로 모든 함수가 동일하게 공통적으로 이용하도록 만들게 되면  크러한 불필요한 메모리
//사용 문제를 최소하 시킬수 있는 것임  그렇기 때문에 기본적으로 정렬배열 같은 경우는 반듯이 전역변수로 만들어 줘야함   
int count = 0;

void merge(int a[], int m, int middle, int n) {// 두개의 정렬된 부분 배열을 이용해서 새롭게정렬된 배열을 만들어 내는 함수   
	int i = m;           // m은 시작점 middle은 중간점 n은 끝점  
	int j = middle + 1;  // 그림과 똑같음  
	int k = m;           // k는 m랑 똑같이 잡아주면 됨 전역변수로 선언된 K는 사실상 i랑 동일한 위치를 가진다고 보면 됨    
	// 작은 순서대로 배열에 삽입 
	while(i <= middle && j <= n) { // 그림처럼 서로 한칸씩 이동 하는 것임  
		if(a[i] <= a[j]) {  // 항상 i와 j를 비교해서 더작은 값을 k에 넣어줌  이걸 반복 하는 것임  
			sorted[k] = a[i]; // i가 j보다 그위치에 있는값이 작다면 K에 i에 있는 값을 넣어줌  
			i++;
		} else {  // 그렇지 않다면 j에 잇는 값을 넣어줌  
			sorted[k] = a[j];
			j++;
		}
		k++;// 이렇게 한번 넣은다음 k값을 이동 시켜줘서 그다음 원소에 값을 받을 수 있도록 만들어 주는 것임  
	}
	// 이제 만약에 i가 먼저 끝날 경우 j는 N까지 도달하지 않은 상황이 될것임 그렇기 때문에 i가 먼저 정렬배열의 모든 원소를 다 넣었다면    
	// 남은 j또한 다 넣어줘야 되고 반대로 j가 먼저 끝났다면 반대로 남은 i를 넣어줌  
	
	// 남은 데이터도 삽입 
	if(i > middle) { // i가 미들보다 크다면  i가 먼저 끝난 거기 때문에  
		for(int t = j; t <= n; t++) { // 남은 j값을 넣어주는 것임 
			sorted[k] = a[t];
			k++;
		}
	} else { // 반대로 j가 먼저 끝났다면  
		for(int t = i; t <= middle; t++) { // 남은 i값을 다 넣어줌  
			sorted[k] = a[t];
			k++;
		}
	}
	// 즉 기본적으로 67 58을 이용해서 5678을 만들었다면 이 5678 자체는 만들어진 순간에는  추가적으로 이용한 일시적인 배열(sorted)이기 때문에  
	// 이제 이걸 실제 배열로 옮겨줄 필요가 있음  
	
	// 결과적으로 정렬된 배열을 삽입            실제배열로 옮겨주는 과정  
	for(int t = m; t <= n; t++) {  // 모든 위치를 다 방문 하면서 
		a[t] = sorted[t];         // 정렬된 배열의 값을 실제 배열의 값으로 이동 시켜주는것임  
	}  
} //이게 이  merge 합치는 함수의 전부  

// 병합 정렬 같은 경우 일단 반으로 나누고 나중에 합쳐서 정렬을 한다고 했음 일단 반으로 나눈 다는 점에서   
// 두가지로 나뉜다는 점에서 재귀 함수로 구현 하는게 가장 좋음  

void mergeSort(int a[], int m, int n) {
	// 이외의 경우는 크기가 1개인 경우 
	if(m < n) { // 크기가 1보다 큰경우만 따질수 있도록  M이 N보다 작은 경우에만 분할을 해줌   
		int middle = (m + n) / 2; //  middle 정중앙을 가리킴 
		mergeSort(a, m, middle); // 정중앙을 기점으로 왼쪽으로 병합 정렬을 수행하고  
		mergeSort(a, middle + 1, n); // 오른쪽으로 병합정렬을 수행함  
		merge(a, m, middle, n); // 그다음 이제 나중에 합쳐줌 정렬된 두개의 배열을   
	}
}

int main(void) {
	int array[number] = {7, 6, 5, 8, 3, 5, 9, 1};
	mergeSort(array, 0, number - 1);  // 정렬을 수행  
	for(int i = 0; i < number; i++) { // 데이터 출력  
		printf("%d ", array[i]);
	}
	
	// 실행하면 재대로 정렬이 된것을 확인할 수 있음  
	return 0;
} 

/* [Error] 'for' loop initial declarations are only allowed in C99 or C11 mode
 오류는 for 안에서 int i 로 선언하는 것이 C 전체 표준은 아니라고 하는군요. c++에선 허용됩니다.
 혹은 int i; 선언을 위에 먼저 해두는 것도 방법은 되겠습니다.

*/
