일반적으로 알고리즘을 공부할 때 가장 먼저 풀어보는 문제는 '정렬(Sort)' 문제입니다.
왜냐하면 정렬만큼 알고리즘의 효율성 차이를 극명하게 보여주는 것이 없기 때문입니다. 그래서 저는 먼저 몇 가지 정렬 알고리즘을 함께 실습을 해 본 뒤에 
알고리즘의 시간 복잡도의 개념에 대해 단계적으로 설명하고자 합니다. 바로 간단한 문제부터 만나보도록 하겠습니다.

다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.
1 10 5 8 7 6 4 3 2 9

위와 같은 문제를 만났을 때 여러분은 어떻게 푸실 건가요? 가장 직관적인 접근 방법은 바로 선택 정렬입니다. 사람은 대략적으로 전체 배열을 확인한 뒤에 1부터 10까지의 숫자를 써내려가겠지만,
컴퓨터에게는 그 과정을 구체적으로 명시해주지 않으면 제대로 컴퓨터는 제대로 작동하지 않습니다. 따라서 알고리즘을 정의해주어야 합니다.

{ 가장 작은 것을 선택해서 제일 앞으로 보내면 어떨까? } 선택정렬에 핵심 아이디어(1)

저는 한 번 가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘을 생각해보았습니다. 사실 이 알고리즘을 바로 '선택 정렬'이라고 합니다. 가장 원시적이고 기초적인 방법 중 하나입니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
먼저 손으로 한번 해보자.
1 10 5 8 7 6 4 3 2 9   알고리즘은 바로 소스코드부터 만지는것이 아니라 반듯이 손으로 먼저 간단한 수식이나 간단한 알고리즘을 테스트 한뒤에 그것을 소스코드로 옮기는것이 가장 효율적임 
처음 1부터 9까지 보면 1이 가장 작음 
1 10 5 8 7 6 4 3 2 9  이미 정렬이 이루어져 있음 그다음 10~9까지 비교 해보면 2가 가장 작음 그럼 서로 위치를 바꿔줌(하나씩 줄면서 비교 ex 1~10 2~10 3~10 ...)
1 2 5 8 7 6 4 3 10 9  이후에는 1 2 3 8 7 6 4 5 10 9  | 1 2 3 4 7 6 8 5 10 9 이런식으로 바꿈 
그렇다면 최종 결과는 1 2 3 4 5 6 7 8 9 10 이 될수 있는 것임 이것이 바로 선택 정렬임 !!

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

선택정렬은 이것만 기억하면됨 : 가장 작은 것을 선택해서 제일 앞으로 보낸다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
코드를 작성하고 오셨으면  
가장 중요한 것은 바로 선택정렬이 얼마나 많은 시간을 잡아 먹는지가 중요함 

1 2 3 4 5 6 7 8 9 10 이걸 정렬하기 위해서는  1부터 10까지 확인 그다음은 2 부터 10 3부터 10 ~~

10 + 9 + 8 + ... +1  즉 몇번에 비교연산을 하는건가? 

이러한것을 고등 수학에서 등차수열이라고 함

=> 10 * (10 +1 ) / 2 = 55   이게 바로 10부터 1을 더한값과 동일함  우리는 총 10개를 계산하기위해서 최소한 55번에 비교연산을 해야된다는 것임   

=> N * (N + 1) / 2  수식으로 표현하면 이럼  즉 이알고리즘의 수행시간은 이렇게 표현할수 있음 
// 하지만 컴퓨터에서는 /2로 나눈 값 같은 경우는 N이 굉장히 크다는 가정하에 의미가 없기 때문에 *간단하게 나누거나 더하는것은 무시함*

=> N * N 그래서 대략적으로 이렇게 표기할수 있음  이 알고리즘 소요시간 N * N

=> O(N * N) 이럴때 사용하는것이 이 빅오 표기법임 특정정의가 있지만 쉽게 생각하자 
그냥 쉽게 특정한 알고리즘의 수행시간을 가장 간략하게 표기하는것임 이 빅오 표기법이다 라고 생각하자 
일반적으로 알고리즘에서는 이 빅오 표기법을 사용함 쉽게 특정한 알고리즘에 총 연산횟수를 간단하게 표현하는거다 라고 생각 
 
그래서 선택정렬은 N제곱 만큼 연산이 필요하다라고 생각하면 됨 

{ 선택 정렬의 시간 복잡도는 O(N^2)입니다. }

ㅡㅡㅡ 자료 내용 
( 위와 같이 정상적으로 실행된 것을 알 수 있습니다. 여기에서 가장 중요한 것은 데이터의 갯수가 N개일 때 총 몇 번의 비교 연산을 해야 되는지입니다.
선택 정렬은 대략 N * (N + 1) / 2 번 가량의 연산을 수행해야 합니다. 이를 컴퓨터에서는 가장 큰 차수인 N^2만 보고 O(N^2)이라고 표현하곤 합니다.
선택 정렬의 시간 복잡도는 O(N^2)입니다. )

다시 말해 정렬해야 할 데이터의 갯수가 10,000 개라면 대략 일 억 번 정도 계산을 한다고 가정을 하겠다는 의미입니다. 
실제로 이 정도의 시간 복잡도를 가지는 선택 정렬이 효율적인지, 그리고 현실 세계의 정렬 상황에서 효과적으로 사용될 수 있을지
고민해보는 시간을 가져봅시다.

실제로 다양한 프로그램에서는 데이터에 개수가 만개 심만개가 넘어가는 경우가 많음 ㅎㄷㄷ..


강의 처음 시작할때 선택정렬은 비효율적인 알고리즘 중 하나라고 했는데 맞는말임
 O(N^2) 정렬 알고리즘 중에서는 굉장히 느린속도고 비효율적인 알고리즘이라고 할수있음 

처리할 개수가 많은 경우에는 최대한 피해야 되는 시간복잡도 중 하나임 ( 개수가 많을만큼 처리해야될 연산이 많아서 N * N(시간복잡도) 이게 선택정렬의 한계임 ) 


최종적으로 말하자면 선택 정렬은 다른 정렬알고리즘과 비교했을때 확실히 비효율적인 알고리즘임 

선택정렬 마스터 ~~~~~~~~~~~~~~~~~ 허허허
