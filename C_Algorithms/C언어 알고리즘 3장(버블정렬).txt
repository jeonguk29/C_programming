
지난 시간에는 가장 작은 값을 선택해서 앞으로 보내는 선택 정렬(Selection Sort) 알고리즘에 대해 알아보는 시간을 가졌습니다. 
이번 시간에는 버블 정렬(Bubble Sort)에 대해 알아보려고 합니다. 문제는 지난 시간에 만났던 문제와 동일합니다. 바로 일련의 숫자들을 오름차순으로 정렬하는 것입니다.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.
1 10 5 8 7 6 4 3 2 9
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
버블정렬의 개념 :

버블 정렬 또한 선택 정렬과 같이 몹시 직관적인 해결 방법입니다. 바로 가까이에 있는 두 숫자끼리 비교를 해서 당장 더 작은 숫자를 앞으로 보내주는 것을 반복하는 겁니다.
옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내면 어떨까?
 다시 말해 버블 정렬이란 옆에 있는 값과 비교하여 더 작은 값을 반복적으로 앞으로 보내는 정렬 방법입니다. 버블 정렬은 정렬 알고리즘 중에서 *구현은 가장 쉽지만* *가장 비효율적인 알고리즘*입니다.
(선택정렬, 삽입정렬, 퀵정렬, 앞으로배울 모든 정렬들 보다 가장 효율성이 떨어지는 알고리즘임) 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
버블정렬 손으로 해보기:

1 10 5 8 7 6 4 3 2 9 버블 정렬 같은 경우는 선택정렬과 마찬가지로 계속해서 특정 범위에 대해서 정렬을 수행하는 알고리즘 

선택정렬은 1 ~ 9, 10 ~ 9, 5 ~ 9 이런식으로 진행했다면 
버블정렬은 1 ~ 9, 1 ~ 2, 1 ~ 3, 1 ~ 5 이런식으로 처음에는 똑같지만 그 다음부터는 뒤에 있는 원소가 하나씩 줄어드는 방식으로 반복을 수행함  
버블정렬은 당장 옆에 있는것과 반복을 함 
1 10 비교 옮길필요 없음 10과 5 비교 옮김 
1 5 10 그다음 10과 8을 비교 이런식으로 1 5 8 7 6 4 2 9 10  한번에 반복이 끝났을때 가장 큰값이 맨뒤로 보내지는 방식임 
즉 결과 적으로 당장 옆에 있는것과 비교해서 계속해서 작은걸 앞으로 옮기는 과정이 결과적으로 한번 반복했을때 가장 큰 값이 맨뒤로 이동하는
결과를 만듬 이제 그다음엔  1 5 8 7 6 4 2 9 이렇게만 비교를 함 
두번 수행 했을 때는 1 5 7 6 4 3 2 8 9 10 가장 큰값이 였던 9가 맨뒤로 보내진것을 확인할 수 있음 
이런과정을 계속 반복하는것임 다시 반복하면  1 5 7 6 4 3 2 8  = 1 5 6 4 3 2 7 8 
결과적으론 1 2 3 4 5 6 7 8 9 10 이런식으로 정렬이 이루어 질것임  

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
버블 정렬 구현 : 
#include <stdio.h>

int main(void) {
	int i, j, temp;
	int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
	for(i = 0; i < 10; i++) {
		for(j = 0; j < 9 - i; j++) {
			if(array[j] > array[j + 1]) {
				temp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = temp;
			}
		}
	}
	for(i = 0; i < 10; i++) {
		printf("%d ", array[i]);
	}
	return 0;
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
버블 정렬의 시간 복잡도 :
 1 2 3 4 5 6 7 8 9 10 이전시간에 배웠던 선택 정렬과 똑같음
=> 10 + 9 + 8 + 7 + ... +1 하나씩 줄면서 더해줌

=> N * (N  + 1) /2 즉 결과적으로 등차 수열이기 때문에  같다고 볼수 있음  방금 한것 또한 55번 연산을함 
    더하기 나누기 와 같은 연산은 N이 크다고 가정했을 때 의미가 없기 때문에 

=> O(N * N) 간단하게 빅오 표기법으로 표현할수 있음 즉 N제곱 선택정렬과 동일한 시간 복잡도를 가지고 있음 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
버블 정렬의 한계점 :
하지만 실제 이것을 작동을 시키면 선택 정렬보다 훨씬 느리게 작동을함 
그이유는 버블정렬 같은 경우는 당장 옆에 있는 것과 비교를 해서 계속해서 자리를 바꾸는 연산을 수행 하기 때문 

temp = array[j];        자리를 바꾸는 연산 같은 경우는 이렇게 총 3개의 명령어를 계속 사용하기 때문에 실제로 컴퓨터가 작업을 해줘야 되는 양이 훨씬 많은것임 
array[j] = array[j + 1];   
array[j + 1] = temp;

선택 정렬 같은 경우는 가장 작은 것을 하나 골라서 마지막에만 교체를 해주지만
버블 정렬 같은 경우는 매번 교체를 해줘야 한다는 점에서 실제로는 훨신더 비효율적이라는 것 임  

그렇게 때문에 기본적으로 시간 복잡도는 선택 정렬과 동일한 O(N^2)이지만  
실제 수행시간을 분석 해보았을때 선택 정렬보다 훨씬 느리다는 특징을 가지고 있음
일반적으로 *정렬 알고리즘 중에서 가장 느린게 버블 정렬임*

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
단순히 반복적으로 두 숫자를 비교하여 앞으로 보냅니다. 이 과정에서 각 싸이클마다 가장 큰 값이 맨 뒤로 보내지게 됩니다. 
컴퓨터 내부적인 연산이 가장 비효율적으로 일어나게 되어 실제 수행시간이 가장 느린 안 좋은 알고리즘이라고 할 수 있습니다. 시간 복잡도는 선택 정렬과 동일합니다.
버블 정렬의 시간 복잡도는 O(N^2)입니다.


