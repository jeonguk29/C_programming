#include <stdio.h>
int main (void)
{
	int i, j, temp; // 지난 시간에 선택정렬 같은 경우는 한번 반복을 할때 마다 가장 작은 값인 최솟값을  min 안에 저장을 해주어야 하는데 
	// 버블 정렬은 그럴 필요가 없음  일단 반복을 위해서 i,j가 필요하고 서로 다른 위체 존재하는 두개에 원소를 바꾸기 위해서 temp가 사용이 됨    
    int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9}; 
    for(i = 0; i < 10; i++) // i를 전체 원소 개수만큼 반복 하고  
    {
    	for(j = 0; j < 9 - i; j++) // 9에서 i를 빼주는 이유는 하나씩 뒤에서 부터 집합의 크기를 하나씩 감소기키는 특징이 있기 때문 
    	{
    		if(array[j] > array[j + 1]) // 당장 반복을 할때마다 옆에 있는것과 비교를 해서 왼쪽에 있는 값이 오른쪽에 있는 값보다 크다면 그위치를 서로 바꿔 주는 것임  
    		{
    			temp = array[j];    // 이전시간과 마찮가지로 템프에 왼쪽에 있는 값을 넣어주고  
    			array[j] = array[j + 1]; // 왼쪽에 있는 원소의 값으로  오른쪽 원소에 있는 값을 넣어주고 
    			array[j + 1] = temp;  // 오른쪽원소의 값에는 기존에 왼쪽에 있던 값을 넣어주는것임  
    			// 이전시간 과 똑같이 두개의 원소위치를 서로 그냥 바꿔주는 것임 명령어 3개를 사용하고 템프라는 변수를 이용해서 두개의 위치가 바뀐것을 알수있음   
			}
		}
	}
	// (정렬 끝) 결과 출력 
    for(i = 0;i < 10; i++)
	{
		printf("%d ",array[i]);
	} 
	
	// 이렇게 간단하게 버블 정렬을 구현 해보았음  
	
		/*
	버블 정렬 
	1. 바로 자신기준 오른쪽과 비교를 함 나자신인 왼쪽이 더크다면 오른쪽과 자리를 바꿈 
	2. 배열의 원소는 마지막이 하나씩 줄어드는 구조임 한번 정렬할때 마다 가장 마지막에 가장 큰값이 있으니까 
	3. 선택정렬과 달리 최소값이 필요없음 
	4. 원소를 비교하는 j를 9까지만 해줌(원래 원소에 하나를 뻄) 밑에 조건문에서 +1 하기 때문에 10 하면 11과 비교를 해버림   
	
	*/
	return 0;
 } 
