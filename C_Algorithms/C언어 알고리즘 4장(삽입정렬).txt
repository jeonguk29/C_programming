지난 시간까지 선택 정렬과 버블 정렬에 대해 알아보았습니다. 앞서 다룬 정렬 알고리즘 모두 시간 복잡도 O(N^2)을 가진다는 점에서 비효율적인 알고리즘에 속합니다.
이번 시간에 다루게 될 삽입 정렬(Insertion Sort)은 어떨까요? 문제는 지난 시간과 동일합니다. (삽입 정렬또한 시간 복잡도 O(N^2) 임)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
삽입 정렬의 개념, 장점 : 
다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.
1 10 5 8 7 6 4 3 2 9

삽입 정렬은 위 문제를 풀 때 각 숫자를 *적절한 위치에 삽입* 하는 방법으로 문제를 해결합니다. 
다른 정렬 방식들(선택정렬, 버블정렬)은 무조건 위치를 바꾸는 방식이었다면 *삽입 정렬은 '필요할 때만' 위치를 바꾸게 됩니다.*
(바로 이러한 특성 때문에 실제로는 선택정렬과 버블정렬보다 더 빠르다는 특징을 가지고 있음)
(또한 삽입 정렬 같은 경우는 특정한 경우에서는 굉장히 빠르게 작동하기 때문에 시간 복잡도 O(N^2)을 가지는 세가지 정렬 알고리즘 중에서는 가장 강력한 알고리즘이라고 할 수 있음.)

각 숫자를 적절한 위치에 삽입하면 어떨까?
바로 알고리즘을 확인해보도록 합시다. 삽입 정렬은 비교적 느린 정렬 알고리즘에 속하지만 쉽게 생각할 수 없는, 조금은 복잡한 구조를 가지고 있습니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
손 으로 정의 :
삽입 정렬 같은 경우는 적절한 위치에 삽입을 하는것임 : 삽입정렬같은 경우는 앞에 있는 원소들이 이미 정렬이 되어 있다고 가정을 하는데요 이 가정을 하는 특성때문에
버블 정렬, 선택 정렬 보다는 조금더 효율적이라는 것임 

1 10 5 8 7 6 4 3 2 9  : 1부터 확인해보면 1이 이미 가장 앞에 있기 때문에 삽입할 위치가 없은 그냥 내버려 두면 됨
_1_ 10 5 8 7 6 4 3 2 9 : 10을 보면 10에 앞을 보았을때 들어갈수 있는 위치가 이렇게 두 군데임 어디로 들어가면 되나 보면 1보다 크기 때문에 그대로 위치를 유지하면 됨 
_1_ 10_ 5 8 7 6 4 3 2 9 : 5는 앞을 보았을때 들어갈수 있는 위치는 총 3군데임 그 중 가장 적절한 위치는 두번째 임 1 5 10 이렇게 정렬이 됨 
_1_ 5_ 10_ 8 7 6 4 3 2 9 : 8을 살펴보면 앞에있는 위치중에서 _1_ 5_ 8_ 10 7 6 4 3 2 9 이렇게 들어가게 됨 이런식으로 원소가 배열이 되고 마찮가지로 계속해서
특정한 원소에서 앞에 원소들을 살펴 보면서 적당한 위치에 들어가는 방식을 채택 하면은 한번 반복할때마다 원소가 적당한 위치에 들어가는 방식으로 계속해서 
하나씩 정렬이 이루어져서 결과적으로 1 2 3 4 5 6 7 8 9 10 으로 정렬이 이루어 지는 것임 

이게 더 효율적인 이유는 
 _1_ 5_ 7_ 8_10_ 6 4 3 2 9     : 6을 보았을 때 6의 앞에 있는 원소들은 이미 정렬이 된 상태임  _1_ 5_ 7_ 8_10 이미 정렬이 되어 있기 때문에 추가적으로 이안에서 또 정렬을 해줄 필요가 없고
단순하게 6을 계속해서 앞에 있는 원소들과 비교 확인 해보면서 6보다 큰값이 왼쪽에 있다면 그 위치만 서로 바꿔 주면 되는 것임 그것만 반복하게 되면 6은 적절한 위치에 들어가게 될거고 
총 7 8 10 만 건너 뛰면 되기 때문에  156 전체를 다 살펴 볼필요가 없는 것임 그렇기 때문에 다시말해서 특정하게 정렬을 해야되는 원소를 만났을 때 이원소에 앞에 있는 것들은 다 이미 정렬이
되어 있다고 볼수 있기 때문에 삽입정렬은 반듯이 필요한 만큼만 이동하기 때문에 선택 정렬과 버블 정렬에 비해서 훨씬 효율적이라는 것임 연산 자체가 더 적게 이루어짐 물론 그래 봤자 
시간 복잡도는 O(N^2) 이라는 점에서 나중에 배울 알고리즘들 보다 더 효율적이라고 말하기 어려움 
이런식으로 삽입 정렬은 적절한 위치에 삽입 하는 정렬 알고리즘이라고 할수 있음.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
삽입 정렬 구현 :
#include <stdio.h>

int main(void) {
	int i, j, temp; 
	int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
	for(i = 0; i < 9; i++) 
	{
		j = i; 
		while(array[j] > array[j + 1])
		{
			temp = array[j];              
			array[j] = array[j + 1];
			array[j + 1] = temp;
			j--;                  
		}                               
	}  
	for(i = 0; i < 10; i++)
            {
		printf("%d ", array[i]);
	}
	return 0;
}

이게 바로 삽입 정렬을 구현 하는 방법 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
삽입 정렬의 시간 복잡도 분석 :
삽입 정렬은 기본적으로 '정렬이 되어있다고 가정'을 한다는 점에서 특정한 경우에 따라 굉장히 빠른 속도를 자랑합니다.
일단 소스코드상 *반복문이 두 번 들어가있다는 점에서(범위를 1 : 1 4 : 1 4 5 이런식으로 확장해 나간다는 점에서 최악에 경우는

1 4 5 6 7 8 10 3 2 9
   이전시간에 했던 선택 정렬과 버블 정렬과 마찬가지로 
=> 10 + 9 + 8 +...+ 1  이런 식으로 연산이 이루어 지기 때문에 ) 시간 복잡도는 O(N^2) 이라고 할수가 있는것임 

즉 시간 복잡도는 선택 정렬, 버블 정렬, 삽입 정렬이 모두 동일 하지만 실제로는 삽입정렬이 가장 연산 횟수가 적게 일어난다는 점에서 세 개 중에서는 삽입정렬이 제일 뛰어난 알고리즘이라고 할수 있음    

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
삽입정렬이 특정한 경우에 있어서 굉장히 효율적일때  : 
하지만 한 번 다음의 경우를 생각해보도록 합시다.

다음의 숫자들을 오름차순으로 정렬하는 프로그램을 작성하세요.
2 3 4 5 6 7 8 9 10 1

만약 데이터가 위와 같이 * '거의 정렬된' 상태 *라면 어떤 알고리즘이 가장 효율적일까요? 
바로 지금 우리가 공부하고 있는 삽입 정렬입니다. 삽입 정렬은 필요할 때에 한해서만 삽입을 진행하기 때문에 데이터가 이미 거의 정렬된 상태에 한해서는 어떤 알고리즘보다도 빠르다는 특징을 가지고 있습니다.

2 3 4 5 6 7 8 9 10 1 이렇게 특정한 배열이 이미 거의 정렬이 되어 있는 경우에는 삽입 정렬이 굉장히 빠른데요 그이유는

2는 처음이니까 제외하고 
3부터 확인 해보면 2보다 크니까 그대로 4도 3보다 크니까 그대로 10 까지 마찬가지임 즉 10 까지는 거의 어떠한 연산도 수행하지 않고 한번씩만 연산을 해서 끝나게 됨 그래서 10까지 올때까지 굉장히 빠르게 연산이 처리가 됨 
이제 마지막으로 1을 보았을때 1은 10과 비교해서 더 작기 때문에  2 3 4 5 6 7 8 9 1 10 => 2 3 4 5 6 7 8 1 9 10 => 2 3 4 5 6 7 1 8 9 10 => 2 3 4 5 6 1 7 8 9 10
이렇게 1을 만났을 때만 1 2 3 4 5 6 7 8 9 10  적절한 위치인 여기 까지 이동을 하는 거지 1이전 까지는 별다른 연산 없이 정렬이 이루어 진다는 점에서 삽입 정렬은 이런식으로 거의 정렬된 상태라면 굉장히
효율적인 알고리즘 이라고 할수 있음 나중에 배우게 될 퀵 정렬, 힙 정렬, 병합 정렬  등 보다 거의 더 빠르거나 동일한 정도의 수준으로 굉장히 빠르게 정렬을 수행한다는 점에서 거의 정렬된 상태라면
삽입 정렬 만큼 자원을 적게 소모하고 빠르게 정렬하는 알고리즘이 없다고 할수 있음 
사실상 거의 정렬된 상태에서는 제일 효율적임 가장 빠르진 안터라도 일단 당장 소모하는 자원도 굉장히 적고 연산 자체도 굉장히 적게 수행하기 때문에 거의 정렬된 상태에서는
삽입 정렬이 제일 깡패라고 할수 있음 
반대로 버블 정렬이나 삽입 정렬 같은 경우는 이렇게 거의 정렬된 상태라고 하더라도 그사실을 알지 못하고 끝까지 다 정렬을 수행하기 때문에 굉장히 느림 
근데 삽입 정렬같은 경우는 특정한 원소를 기준으로 앞에 있는 것들은 이미 정렬이 되어 있다고 가정을 하기 때문에 훨씬 빠르게 정렬을 수행 할 수 있는 것임


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
보충 자료
삽입 정렬을 완전히 이해하기 위해서 삽입 정렬이 수행되는 과정을 일일이 출력하는 프로그램을 작성해 볼 수 있습니다. 다음과 같이 여러 개의 숫자가 들어왔을 때 이를 삽입 정렬하는 과정을 출력해보세요.

< 예시 입력 >

10
26 5 37 1 61 11 59 15 48 19

< 예시 출력 >

26 
5 26 
5 26 37 
1 5 26 37 
1 5 26 37 61 
1 5 11 26 37 61 
1 5 11 26 37 59 61 
1 5 11 15 26 37 59 61 
1 5 11 15 26 37 48 59 61 
1 5 11 15 19 26 37 48 59 61

< 정답 소스코드 >

위와 같은 경우는 아예 특정 위치에서 시작해서 왼쪽으로 이동하며 자신보다 작은 것을 만날 때 그 위치에 원소를 삽입하면 됩니다. 따라서 기존의 소스코드를 약간 수정하여 정답을 도출할 수 있습니다.

※ 소스코드 수정(2018-07-15) → (j > 0 세그멘테이션 오류 수정)
#include <stdio.h>

int n;
int array[101];

int main(void) {
	int i, j, temp, n;
	scanf("%d", &n);
	for(i = 0; i < n; i++) {
		scanf("%d", &array[i]);
	}
	for(i = 0; i < n; i++) {
		j = i;
		while(j > 0 && array[j - 1] > array[j]) {
			temp = array[j - 1];
			array[j - 1] = array[j];
			array[j] = temp;
			j--;
		}
		for(j = 0; j <= i; j++) {
			printf("%d ", array[j]);
		}
		printf("\n");
	}
	return 0;
}















