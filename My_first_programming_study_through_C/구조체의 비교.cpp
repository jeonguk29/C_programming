// 한번 작성된 프로그램을 계속해서 반복해서 코딩해보시고 완벽하게 이러한 쓰임세에 대해서 이해해보며 프로그램에  재미를 느끼는것이 증요함 
/*
#include <stdio.h>

struct point{ // 구조체 포인트는 인트 x와 인트 y라는 속을 가지고 있다 정의 
	int x;
	int y;
}; 

int main (void)
{
	struct point p1; // 다음과 같이 점 두개를 메인 함수에서 사용해볼것임  
	struct point p2; 
	
    p1.x= 30; //포인트 1의 즉 첫번째 점의 x좌표가 30이고 y좌표가 10이고  
	p1.y= 10;                        
	
    p2.x= 30; // 그다음에 두번째 점같은 경우에도 마찮가지로 x가 30 y가 10일때  	 
	p2.y= 10;
	
	오류 나는 부분  
    if(p1 == p2)// p1과 p2는 같다고 할수가 있을까? 
	{
		printf("p1과 p2가 같습니다."); //라고 해준뒤 실행을 해보면 오류가 발생하는데 
		// ** 구조체는 아무리 같은 구조체 타입(point) 이라고 하더라도 그속성인 두개의 변수 자체를 직접 비교하는 것은 불가능함 (x.y) 이렇게 한번에 두개
		// 그래서 즉 p1과 p2는 그자체만으로 쓰일수 없기 때문에 오류가 나는것임 (속성안에 있는 2개의 변수를 한번에 비교할수없어서)   
	 }

    올바른 부분  
    if((p1.x == p2.x) && (p1.y == p2.y)) // 두개를 정확하게 비교하려면 이렇게 비교하는게 올바른 판단이라고 할수 있겠음   
    {                                    // 왜냐면 이포인트라는것은 우리가 좌표 평면 상에서 하나의 점을 의미한다고 했기 때문 
    	printf("p1 과 p2가 같습니다."); // 이런경우 이제 p1과 p2가 같다고 표현할수 있는것임  
	}
	 // 이건 굉장히 의미가 있는데 구조체 자체는 그대로 비교를 못한다는 점을 확실하게 이해하고
	 // 이런식으로 각 구조체별로 특징을 잡아서 이렇게 비교 하는 부분을 따로 만들어줘야 된다는것을 이해 할수 있었음  
	return 0;
 } 
 */
 
#include <stdio.h>

struct point{ 
	int x;
	int y;
}; 

void comparepoint(struct point p1, struct point p2) //이걸 이제 이렇게 함수로 만들수 있는것임  
{                                                  // 이렇게 따로 아예 함수로 만들어서 관리할수가 있는것임 
	 if((p1.x == p2.x) && (p1.y == p2.y))     // 그리고 이걸 밑에서 이렇게 올릴수가 있음 이런식으로 하는것이 훨씬 합당함  
    {                                    
    	printf("p1 과 p2가 같습니다."); 
	}
} 

int main (void)
{
	struct point p1; 
	struct point p2; 
	
    p1.x= 30; 
	p1.y= 10;                        
	
    p2.x= 30; 
	p2.y= 10;
    
    comparepoint(p1,p2);// 자료형 다빼고 변수만 넣어주는거니까 이렇게 써야함 
	
	//실제로 이런식으로 정말 많이 구현이됨      이렇게 실행했을때도 똑같이 같은 결과를 보여주지만  
   
   /*
   if((p1.x == p2.x) && (p1.y == p2.y))     
    {                                    
    	printf("p1 과 p2가 같습니다."); 
	}
   
   이게 매인 함수에 있는것 보다 훨씬더 체계적으로 보인다고 할수 있음 왜냐하면 포인트 라는 구조체 하나만 비교하는 함수가 
   위에처럼 들어가 있기 때문 그럼 메인함수에서는 이제 그걸 사용만 해주면 되기 때문에 설계적으로 훨씬 깔끔한 구조가 체계적인 구조가
   이루어 졌기 때문임     
   */
	  
	return 0;
 } 
 
