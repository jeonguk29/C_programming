#include<stdio.h>
#include<stdlib.h>// 동적 메모리를 위한 헤더파일을 추가해주고  
int main (void) 
{
	//아까와 비슷하게 포인터 변수를 만들어주는데 이번에는 char 케릭터형임 왜냐하면 알파벳을 출력하기 위해서니까 문자열이 필요하기 때문 
	
	char *pc=NULL; // 자 다음과 같이 *포인터 케릭터를 넣어주고 처음에는 널값을 넣어줌 그럼 케릭터형의 포인터 변수 pc는 현제 아무것도 가르키는게 없다  
	               // 라고 해준것임 
    int i =0; //그다은 int i에 0을 넣어줌   그리고 pc를 다음과 같이 초기화 해주는데
	
	pc = (char *)malloc(100 * sizeof(char)); // char *에 특정 메모리를 할당해줄수 있도록함 (100 * sizeof(char)) 바로 이메모리
	// (100 * sizeof(char)) 아까와 좀 다른데 아까전에 했던 예재 같은경우는 sizeof(int)와 같이 단한개의 변수가 들어갈수 있는 만큼에 메모리 공간을
	//할당해주었는데 이젠 이렇게 사이즈오프 케릭터 곱하기 100을 해주었음 즉 하나의 케릭터 즉 하나의 문자가 들어갈수 있는 공간이
	// 100 x 공간 개 만큼이니까 총 100개의 문자가 들어갈수 있는 문자열을 위한 이러한 공간이 할당이 됬다고 할수가 있는것임  
	// 즉 총 100개의 문자가 이 pc포인터를 이용해서 들어갈수 있는것임니다  
					    
	if(pc == NULL)// 동적메모리 할당에 실패 했다면 밑에와 같이 출력해주면 됨  
	{
	  printf("동적 메모리 할당에 실패했습니다.\n");	
	  exit(1);// 그리고 이렇게 해주어서 프로그램을 정상적으로 종료해주시면 되는것임  
	}				    

    /* 추가적으로 설명하자면 이렇게 
	pc = (char *)malloc(100 * sizeof(char)); 같은 경우는 사실상 배열과 거의 동일하다고 할수가있음 배열같은 경우도 특정한 자료형을 
	총몇개 만큼 들어갈수있는 공간으로 처음에 초기화를 해주잖아요 그것과 마찬가지로 동적 메모리 할당 또한 이런식으로
	사이즈 오프 케릭터의 크기만큼이 100개가 할당된다 즉 케릭터가 100개가 들어갈수 있는 공간을 만든다 이런식으로 이해하면 됨  
	*/				 
	
	/* 메모리 할당이 성공했을때 이렇게 pc가 가르키는 포인터를 1씩 증가시키며 알파벳 소문자를 삽입합니다. */   // 이제 이것을 해볼것인데 
	for(i=0; i<26; i++) //i는 0부터 시작해서 총 알파벳의 개수인 26개 만큼 i를 1씩 더해가면서 어떠한 연산을 해줄것인데 
	{
		*(pc + i) = 'a' + i;   // 이와같음 이게 무슨 의미냐면은 이걸처음 봤을때는 잘이해가 안갈수 있는데 그림판을 이용해 설명 해볼것임  
	}
	
	/*
	  자 맨처음에 이렇게 pc라는 포인터 변수를 초기화 했을때 어떠한 일이 일어날까요? 
	  
	         __________________
	        |                  |        // pc는 메모리가 있을때 100개 만큼의 공간을 할당한 첫번째 주솟값이 되는것임  
	  pc => |  ㅁ              |       // 예를 들어 이렇게 1바이트가 있을때 이렇게 만들어 질것임  
	        |                  |          근데 지금은 이 1바이트의 케릭터 자료형을 총 100개만큼 할당했기 때문에  
	        ____________________ 
	  
	         __________________
	        |                  |        
	  pc => |  ㅁㅁㅁㅁㅁㅁㅁㅁ| 이렇게 연속적으로 이어져서 특정한 공간을 100개만큼 차지를 하게 되는것임          
	        |                  |          
	    
		    ____________________ 그럼 바로이 첫번재 케릭터형에 해당하는 공간이 왼쪽처럼 저 첫번째 ㅁ 즉 이 pc 가 가르키는 주솟값이 되는거죠    
	  pc => |   ㅁ             |        
	        |                  |     다른 말로 하면은 *(pc) 라고 한다면 바로 이 왼쪽 ㅁ 바로여기 안에 들어가있는 특정한 값이 되는것임     
	        ____________________     만약에 이안에 값이 100이 들어가있다면 100이 나올것이고 99가 들어가 있으면 99가 나올것임   
	                                즉 이왼쪽에 처음 ㅁ 에 해당하는 값 자체를 의미하는게 이 *(pc) 임 
									
		그렇다면 이 *(pc+1) 은 어떻게 될까요?
	
			____________________      
	  pc => |  ㅁㅁ            |  이건 바로 첫번째 값에 해당하는 주소의 다음 번째 주소의 해당하는 값을 의미하죠            
	        |                  |  즉 2번째 ㅁ의 값을 의미하는 것임         
	        ____________________							
									
      *(pc+1) 		 이런식으로 1씩 더해나간다면은 바로 다음칸으로 이동하면서 다음칸에 해당하는 그러한 값들이 나오는것임  
	  *(pc+2)
	  *(pc+3)								 
	         즉 마치 배열과 같다고 할수있음 
	         
	  *(pc+1)  = pc[0] 이거 같은 경우는 배열이 있을때 이렇게 배열 0번째 인덱스가 되는거고 	
	  *(pc+2)  = pc[1] 이거 같은 경우는 배열 1번째 인덱스가 되는것임  
	  *(pc+3)  = pc[2]		  
	
      사실상 이 *(pc)는 배열과 다를게 없는거에요 즉 동적메모리 할당으로 이렇게 포인터로 관리하는거랑 배열로 관리하는거랑 사실상 비슷한 원리를 
      가지고 있다는것을 이해할수있음 
	 
	for(i=0; i<26; i++)  
	{
		*(pc + i) = 'a' + i; // 즉 이렇게 처음시작할때 i =0 이라고 할때 이렇게 첫번째 위치에다가 a라는 문자를  넣고 거기에 0을 더했으니까      
	}                           즉 a라는 문자가 들어가겠죠  
	                            그이유는 이 a라는 문자는 아스키코드에서 97번재 해당한다고 말했는데  
	
			____________________      
	  pc => |  ㅁ              |  그렇기 때문에 i가 0일때 첫번째 이위치에 a라는 문자가 들어가는것임          
	        |                  |     
	        ____________________
	
			____________________      
	  pc => |  ㅁㅁ            |   2번째위치 i가 1이 됬을때는 문자 a에 1을 더한값 즉 아스키 코드로 98이 되기 때문에            
	        |                  |   2번째는 b가 들어가는거죠 아스키코드로 98은 b를 의미하기 때문이에요  
	        ____________________
	 
	 이런식으로 a,b,c,d 하나씩 들어가는거죠 언제까지냐면은 알파벳 총개수인 26까지 즉 z 까지 이렇게 들어가는것임 
	 바로 이렇게 간단하게 포인터를 이용해서 1씩 더해가면서 a~~z까지 모든 문자를 이렇게 넣을수가 있는것임   
	
	사실이건 정말 동적 메모리를 이용한 배열관리에 대표적인 예재라고 할수있음
	이러한 형식 자체를 완전하게 이해하면 나중에 정말 동적 메모리를 사용할때 편리하다고 할수가 있음   
	*/
    // 이제 한번 다음과 같이 해주겠음
	*(pc + i) = 0; // 포인터 pc+i 에 0을 넣어 주는데 이제 i는 26까지 반복하기 때문에 이반복문을 탈출했을때 여기 i에 도착했을때는 26이 됩니다. 
	               // 즉 z바로 다음에 해당하는 문자로 이렇게 아스키코드 0에 해당하는 문자를 넣어줌니다. 
	/* 여기서 아스키코드 0은 NULL을 의미합니다. */	// 즉마지막 문자로 NULL을 넣어준거죠  
	
	/* c언어에서 문자열은 문자의 배열로 표현이 된다고 했는데 문자가 들어가다가 마지막에 null을 만나면 그게 문자열의 종료를 의미한다고 했었음 
	         ___________________
	 pc =>  |  a~~~~~~z'0'     |    즉보시면 이렇게 z가 들어가고 z다음으로 NULL 값이 들어가는거에요           
	        |                  |    이렇게 널값이 들어가게 되면은 이제 컴퓨터는 이 pc가 가르키는 주소 바로 이 첫번째 a 부터 z 까지 읽고 
	        ____________________    마지막에 널값을 만나고 아 이제 문자열이 끝났군아 하고 이 pc라는 문자열 포인터에 종료를 인식하는거죠  
	
	즉 이런식으로 널값을 마지막에 삽입함으로써 문자열의 종료를 알릴수가 있는거에요  
	
	for(i=0; i<26; i++) 
	{
		*(pc + i) = 'a' + i; 
	}
	*(pc + i) = 0;             이제 여기까지 해서 완벽하게 하나의 문자열을 만들게 된거죠  
	
	*/
	
	printf("%s\n",pc); // 이렇게 해서 이제 문자열 pc를 출력하게 해주면 되는것임  
                             	
	/* 저번에도 말했듯이 c언어에서 문자열 %s라는 형식 지정자를 이용해서 문자열을 출력하게 되면은  
	        ___________________ 
	 pc =>  |  a~~~~~~z'0'     | 내부적으로는 이렇게 앞에 a부터 하나씩 출력해나가다가 NULL값을 만나면           
	        |                  | 그것까지 문자열로 인식해서 종료한다음 이렇게 a~z까지 출력하는 형식으로 이루어 진다고 했었죠  
	        ____________________
	
	즉 아까도 말했듯이 이렇게 %s같은 경우는 NULL값을 만날때까지 하나의 문자열로 인식해서 그걸 출력 해준다고 했었어요  
	즉 a~z까지가 차례대로 출력이 되는것입니다.  
	*/
	
	free(pc); // 그리고 이제 마지막으로는 말씀드렸듯이 동적 메모리를 할당해지해주면 됩니다. 이렇게 프리 한다음 해당포인터 변수 pc를 ()안에
	          // 넣어줌으로써 
   /*	
             ___________________  
	 pc =>  |  a~~~~~~z'0'     |   안에 있는 a부터 NULL 까지 다 할당 해지해주는거죠 즉 이제 이부분은 할당 해지 해줌으로써 프로그램상에 다시         
	        |                  |   어떠한 변수를 위한 메모리 공간으로 사용될수가 있는것임  
			____________________		  
	        ____________________
	 pc =>  |                  |    이런식으로 할당해지 그리고 새로운 메모리 공간으로 사용될수 있는것!           
	        |                  |    
	        ____________________		   
	
	
	즉 이제 이렇게 free 까지 해줌으로써 메모리 할당해지 까지 해줌으로써 프로그램이 완벽하게 짜여진것을 알수 있습니다. 
   한번 다음과 같이 실행을 해보시면은 이렇게 a~z까지가 정상적으로 출력이 되는것을 알수있습니다.  
   
   */
	
	
	return 0;
 } 
 
 
/* 
#include<stdio.h>
#include<stdlib.h>
int main (void) 
{
	
	char *pc=NULL; 
    int i =0; 
	
	pc = (char *)malloc(100 * sizeof(char)); 

	if(pc == NULL)
	{
	  printf("동적 메모리 할당에 실패했습니다.\n");	
	  exit(1); 
	}				    
	
	메모리 할당이 성공했을때 이렇게 pc가 가르키는 포인터를 1씩 증가시키며 알파벳 소문자를 삽입합니다.    // 이제 이것을 해볼것인데 
	for(i=0; i<26; i++) 
	{
		*(pc + i) = 'a' + i;   
	}
	*(pc + i) = 0;  
	여기서 아스키코드 0은 NULL을 의미합니다. 	// 즉마지막 문자로 NULL을 넣어준거죠  
	
	printf("%s\n",pc);
	free(pc); 

	
	return 0;
 } 
 
 */
 
 
 
 
