/* 
자 이제 마지막으로 해볼 예재는 동적 메모리를 이용해서 2차원 배열을 다루어 보는건데요 
사실 여기까지는 강좌에서 다루어 봐야할지 고민을 많이 했는데요 그래도 일단 동적메모리가 정말 익숙해 지기 위해서는 여기까지 
한번 건드려 볼 팔요가 있다고 생각을 해서 한번 넣어 보았습니다. 
여기 까지 구현을 할수 있다면 동적 메모리는 정말 거의 대부분 이해를 했다고 할수가 있고 c언어에 기초문법은 다 땟다고 할수가 있음
한번 다음과 같이 바로 실습을 해보겠음   
*/

#include <stdio.h>
#include <stdlib.h>

int main (void)
{
	int i,x,y; // 자 말씀 드렸듯이 동적 메모리를 이용해서 2차원 배열을 한번 만들어 봐야되는데 그렇기 때문에 이렇게 i,x,y를 이렇게 하나씩 변수로써 
	          // 선언을 해주겠습니다. 
/* 
     그다음 이제 그때 말씀 드렸듯이 2차원 배열이 라는것은 배열의 원소로 배열이 들어가는 것이라고 했어요 
	 그러니까 즉 
	 일반적인 1차원 배열 같은 경우는 | 0| 1| 2| 3| 4| 5| 이제 이런식으로 하나씩 값이 들어가는 구조라고 그러니까 일반적인 원소가 하나씩 들어가는
	 구조라고 했다면   
	 뭐 예를 들어 int array [10] 인트형에 어뤠이 라는 배열이 총 10개만큼에 데이터가 들어갈수 있는 공간이라고 했다면
	 | | 이러한 상자가 10개가 할당이 되서 위처럼 각각의 위치에 하나씩 인트형의 원소가 들어간다고 했는데  
	 만약에 이제 이런식으로 
	 array [10][10]; 이렇게 입력이 된다면  2차원 배열이 만들어 진다고 했었습니다.
	 ㅁ| | | | | | | | | | 즉 이각악에 ㅁ 원소에 10개 만큼에 배열이 들어가는거랑 동일하다고 했죠? 
	 ㅁ                  | 바로 이러한 구조가 2차원 배열이라고 말했었습니다. 
	 ㅁ                  |
	 ㅁ
	 ㅁ
	 ㅁ
	 ㅁ
	 ㅁ
	 ㅁ
	 ㅁ                    동적 메모리 할당을 이용한 구현 방법자체도 이거랑 크게 다를게 없는데요 
	  바로 다음과 같이 해줄수 있습니다.								 	
*/
    int** pptr = (int**)malloc(sizeof(int*) * 8);  
    /* 이 인트 포인터 포인터 tr에 인트 포인터 포인터 에 할당 하다 인트가 들어갈수 있는 포인터 공간 만큼에 8곱한 만큼 만들어서 
	             int*
	    * pptr =  | |  
                  | |
                  | |
                  | | 요게 다 int* 변수인것임  
                  | |
                  | |
                  | |
                  | |
                  | |
                  | | 즉 이런 구조인것임 
	좀 해괴망측 하고 쉽지않다고 느낄수 있긴 한데요 네! 맞습니다. 솔직히 쉽진 않은데 동적 메모리를 좀 익숙하게 다루어 보기 위해서는 이정도 까지 조금 
	오바를 해서 건도려 볼 필요가 있는거죠  
    
    자다시 그림으로 좀더 설명해볼게요   
	             int*
	   즉* pptr =  | || || || || || || || || || | 이처럼 포인터 변수를 8개 만들어 준다고 생각하시면 되요   
	  이렇게 총 8개의 데이터가 연속적으로 만들어 지는거죠 그리고 | | 이각각의 상자들은 하나씩다 int* 인트형 포인터가 되는거고요 
	  이제 이거 하나 하나가 전부다 포인터가 되는거죠 8개라고 했으니가 이러한 포인터 변수가 8개가 만들어 지는것임 
	  그렇다면 이제 이하나 하나의 포인터변수는 어떤 의미를 가지고 있을까요 말씀 드렸듯이 포인터는 배열과 흡사하다고 할수가 있어요  
	  즉 int형 배열을 가질수 있는 각각의 포인터가 만들어 진거죠  
	  한마디로 | | 이거 하나 하나가 또 어떠한 배열을 가르키는 그러한 포인터 변수가 된거라고 할수가 있는거에요  
	  
	          |             |
                   	^ 
	 int** pptr =  | || || || || || || || || || |  바로 int** pptr = (int**)malloc(sizeof(int*) * 8); 이게 옆에 그림과 같은 의미라고 할수 있습니다. 
  	                   v
  	             |    int 형   |    
	  
	  그러다면 지금이 | |  포인터 같은 경우는 초기화가 되지 않았죠? | int형 | 이게 얼마만큼에 크기인지도 모르고요 그렇기 때문 에 바로 다음과 같이 
	  */
	for(i = 0; i < 8; i++) // i는 0부터 8까지 1씩 증가하면서 다음과 같이 해줌니다. 
	{
	    *(pptr + i) = (int *)malloc(sizeof(int) * 6); 	
	}//포인터 피피티알 플러스 i는 밑에처럼 증가하겠죠? (int *)malloc(sizeof(int) * 6); 이제 여기에서 기본적인 동적 메모리 할당을 해주면 되는거에요   
	 //  *(pptr + 0)  : 그럼 1번째 int형을 가리키고 있는 상자는 인트형 6개가 들어갈수있는 배열과 같다  
	 //  *(pptr + 1)   즉 int* = 인트6개의 배열  
	 //  *(pptr + 2) 
	 /*
	 다시 즉 이렇게  
	     | | | | | |0 |    
                   	^ 
	 int** pptr =  |0 ||1 || || || || || || || || | 이부분에 | | 이각각의 하나의 변수가 6개만큼의 위치를 포함하고 있는 어떠한 배열의 첫번째 값을   
  	                   v                            가르킨다고 생각하면 됨 
  	                  |1 | | | | | |
						
	나만의 총정리 !!!!!!!
	나누어서 생각하는게 편함  
	1.int*\2.* pptr = 3.(int**)malloc(sizeof(int*) * 8);	                      int*  그냥 인트형을 가르키는 * pptr 포인터 배열이라 생각   			
	1. 이부분은 그배열 하나당 어떤자료형의 어떤값이 들어가는지 설정하는 부분 즉 합체형임 					
	2. 이부분은 오른쪽 배열의 상자 순서를 뚯함 	
	3. 이부분은 int** 합체형이 8개의 포인터 배열을 생성한다는 뜻임 				    
	이렇게 해주면 
		          |             |
                   	^ 
	 int** pptr =  | || || || || || || || || || |        이과 같은뜻  
  	                   v
  	             |    int 형   | 
  	             
  	                int*  인트를 가르킴  
	   즉* pptr = 0 | |  포인터 배열 pptr이  
                  1 | |
                  2 | |
                  3 | |   
                  4 | |
                  5 | |
                  6 | |
                  7 | |
                  8 | |
                  9 | |
		그다음 어떤 int형을 가르켜 주는지 설정해줌 		  
		for(i = 0; i < 8; i++)  
	{
	    *(pptr + i) = (int *)malloc(sizeof(int) * 6); 즉 int* = 인트6개의 배열	
    }
	    *(pptr + 0) 0번 째 상자는 = int* =6개의 인트형 배열       
	    *(pptr + 2) 
	                
					int*  인트를 가르킴  그인트는 6개의 인트형 배열  
	   즉* pptr = 0 | | = | | | | | | | 요줄은  *(pptr + i) = (int *)malloc(sizeof(int) * 6); 여기를 의미하는것임  
                  1 | | = | | | | | | |
                  2 | | = | | | | | | |
                  3 | | = | | | | | | |  
                  4 | | = | | | | | | | 
                  5 | | = | | | | | | |
                  6 | | = | | | | | | |
                  7 | | = | | | | | | |
                  8 | | = | | | | | | |
                  9 | | = | | | | | | | 
                    ||
 즉 이줄은 int** pptr = (int**)malloc(sizeof(int*) * 8); 여기를 의미하고                
	
    다시  이렇게  
	     | | | | | |0 |    
                   	^ 
	 int** pptr =  |0 ||1 || || || || || || || || | 이제 여기에서 하나씩을 초기화 해주는데   
  	                   v                            하나씩 초기화 되는것은 각각 어떠한 위치에 있는  
  	                  |1 | | | | | |                6개만큼에 인트형공간을 차지를 하는 이러한 배열의 첫번째 값을 가리키는 
						                            포인터가 됬다고 할수가 있는거죠
		이렇게 해서 8개의 포인터 배열이 각각 6개의 인트형 배열을 가르키면서 초기화를 했다고 할수가 있는거에요
		
		초기화란 : 컴퓨터 프로그램의 최초 또는 미리 정해진 계수, 스위치, 주소, 기억 장치의 내용 등을 ‘0’ 또는 기타의 값으로 설정하는 것. 				  
		즉이제 여기 까지가 이렇게 총 48개 만큼에 int형 2차원 배열 공간을 만들어 줬다고 할수가 있는거죠 
		왜 48개냐면은 6개의 공간에 들어갈수 있는 배열을 총8개 할당해 주었기 때문에 총 48개라는 의미입니다.				                            
	
        자이제 이렇게 동적 메모리를 이용해서 2차원 배열 할당이 이루어 질수 있다는것을 이해할수 있고요. 	
	
	   이렇게 할당이 이루어 진것들을 바로 다음과 같이 처리를 할수가 있어요  
	 */ 
	 for(y = 0; y < 8; y++) // y는 0부터 8까지 1씩 증가할때마다  
    {
        for(x = 0; x < 6; x++) //x는 0부터 6까지 증가함  
		{
			*(*(pptr + y) + x) = 6 * y + x; // 그리고 이렇게 해주면 됨.   확실히 쉽지는 않지만 이렇게 해주게 되면은 여기서 말하는 x는
		/*	      | 0| | | | | | =>      || 이 갖갖이 작은 공간 하나하나가 되는거고요 => 방향으로 하나씩 증가해서 6까지 증가한다음에  
                   	^                                 6이됬을때 y가 1증가하죠? 그때 y는 두번째 공간으로 넘어 감니다. 
	 int** pptr =  |0 ||1 || || || || || || || || | 
  	                   v                            
  	    	          |1 | | | | | |     이런식으로 y가 8이 되고 6까지 모두 증가했을때 는 즉 이부분을 수행했을때는
			                             총 48개 크기에 모든 인트형 배열이 초기화가 이루어 지는거에요 
										 초기화가 이루저 질때 6 * y + x; 값을 보면 y는 x가 6씩 와따 같다 할때마다 
										 y가 6과 곱해지기 때문에 
				*(*(pptr + 0)+1) = 6x0+0
				  | 0| 1| 2| 3| 4| 5| =>             이것과 같다고 할수있어요  
                   	^                         *(*(pptr + 0)+1) = 6x0+1   *(*(pptr + 0)+2) = 6x0+2   *(*(pptr + 0)+3) = 6x0+3
	 int** pptr =  |0 |	    
  	    
		              | 6| 7| 8| 9| 10| 11| =>               
                   	    ^                         *(*(pptr + 1)+0) = 6x1+0   *(*(pptr + 1)+1) = 6x1+1   *(*(pptr + 1)+2) = 6x1+2
	 int** pptr =  |0 | 1|
		                          
		                                이런식으로해서 하나씩 1씩 증가하면서 값이 초기화 될것이라고 예상할수가 있는것임 
		  즉 처음봤을때는 정말 난해하고 어려워 보이지만 하나하나 정말 세부적으로 분해를 해서 이해를 하려고 해보시면 충분히 이해할수가 있습니다. 
	    
		나만의 정리  
		2.|*( |1.*(pptr + y)| + x)| = 6 * y + x;
		1.*(ppyr +y ) *거는 pptr을 기억해주기 위해서 써준 *임 위에 인트러 써주어 인트가 생략이 되니까 int 쓰지 말아야함 쓰면 오류
		  즉 +y 는 인트형을 가르키는 포인터 pptr 배열의 순서를 말함   0 번째 1번째 이런식으로 배열중 인트형을 가리키는 포인터의 순서를 의미  
		
		2.*(     + x) 요건 그각각의 포인터 배열이 가르키는 포인터 변수들이 가르키는 인트형 배열의 순서를 의미함 1~6까지 
		그래서  ( () ) 요렇게 가로가 두개 필요한것임 ** 도 두개필요한거고   
		*/	          
		}	     
	}	
	 // 그리고 이제 마지막으로 이렇게 초기화가 된것을 차례대로 출력하는 방법에 대래서 알아보겠습니다. 
	for(y = 0; y < 8; y++) // y는 0부터 8까지 1씩 증가하고  
	{
	    for(x = 0; x < 6; x++)// 그와동시에 x는 0부터 6까지 1씩 증가하면서  
		{
		    printf("%3d", *(*(pptr + y) + x));	// 이와같이 하나씩 출력해줌  %3d는 출력을 할때 공간을 3개의 공백만큼 차지하겠다는 의미  
	    }// 이렇게 되면이제 위에서 초기화 했던 값들이 하나씩 차례대로 출력이 되는것인데요  
	     // 이제 이렇게 x가 한번 6만큼 돌았을때는  
		printf("\n"); // 이렇게 띄어 쓰기를 해줌으로써 완벽하게 작동할수 있습니다. 
	}
	/* 그리고 마지막으로 이제 다음과 같이 y는 0부터 8까지 1씩 더해나가면서  
	   | | | | | |0 |  각각에 해당하는 이왼쪽에 작은 메모리들 있자나요 이부분을 다로 해지해주고  
                   	^ 
	 int** pptr =  |0 ||1 || || || || || || || || |   
  	                v                    
  	               |1 | | | | | | 이부분 해지해주고 이런식으로 하나씩 전부타 8개를 전부다 해지해주면 되는것임  
	*/
	for(y = 0; y < 8; y++) // 다음과 같이  
	{
		free(*(pptr + y));// pptr + 0~7 까지 pptr이 가르키는거 보두 해지 pptr은 물론 pptr이 해지되면서 가르키는것도 해지되는거니까  
	} // 이런식으로 해주게 되면은 갖갖이 6개의 크기에 해당하는 배열들이 이 8개만큼 전부다 할당 해지가 되는거죠      
	/*
	즉   * pptr = 0 | x| = x
                  1 | x| = x
                  2 | x| = x
                  3 | x| = x  
                  4 | x| = x 
                  5 | x| = x
                  6 | x| = x
                  7 | x| = x
                  8 | x| = x
                  9 | x| = x   즉 이렇게 해줌으로써 정상적으로 프로그램이 완료가 되는것입니다.
		
		한번 실행을 해보면 
		0~5
		6~11
		12~17
		18~23
		42~47   이런식으로 6개만큼 총 8개의 배열이 하나하나씩 출력이 되는것을 알수있고요 
		        이렇게 전부다 출력이 된 이후에는 정상적으로 메모리 할당을 해지하고 프로그램이 종료가 되는것이죠 		  		   
	*/
	   
 	return 0; 
 } 
 
 /*
 네 이제 한번 이렇게 동적 메모리를 어떻게 하면 다방면으로 활용할수 있을지에 대해서 공부를 해보았는데요 
 정말 동적 메모리 자체는 개념자체가 쉽지는 않지만 이렇게 동적 메모리를 확실하게 이해한다면은 
 전반적으로 프로그램이 메모리를 어떨게 잡아먹고 메모리를 어떻게 활용하는지에 대해서 이해를 할수가 있고
 그러한 개념이 트이게 되면은 그때부턴 정말 웬만한 프로그램에 대한 이해도가 상당히 높아진다고 할수가 있어요
 말씀 드렸듯이 c언어에서 동적 메모리는 가장 마지막에 배우는 가장 마지막 단계에 문법이라고 할수가 있고 
 이제 여기까지 공부를 다맞췄다면 자료구조나 알고리즘과 같은 더욱 심화적인 내용을 공부할수 있는거고 
 기초문법이 다 끝났다고 할수 있는것입니다.      
 */

/* 
#include <stdio.h>
#include <stdlib.h>

int main (void)
{
	int i,x,y; 
	        
    int** pptr = (int**)malloc(sizeof(int*) * 8);  

	for(i = 0; i < 8; i++) 
	{
	    *(pptr + i) = (int *)malloc(sizeof(int) * 6); 	
	}   

	 for(y = 0; y < 8; y++)  
    {
        for(x = 0; x < 6; x++) 
		{
			*(*(pptr + y) + x) = 6 * y + x;       
		}	     
	}
	
	for(y = 0; y < 8; y++) 
	{
	    for(x = 0; x < 6; x++) 
		{
		    printf("%3d", *(*(pptr + y) + x));	  
	    } 
		printf("\n");  
	}

	for(y = 0; y < 8; y++)   
	{
		free(*(pptr + y));
	} 
	
	   
 	return 0; 
 } 

*/ 
 
